//The method get_response()
/*
1.virtual task get_response( 	output  	RSP  	response,input  	int  	transaction_id 	 =  	-1 	)
2.purpose:-
 -> Retrieves a response item from the sequencer:-
    it enables a sequence to obtain the response generated by the driver following the execution of a transaction on the DUT.
 -> Facilitates bidirectional communication:-
    it is crucial for the sequences that need to process or make decision based on DUT behavior.
3.called by sequence:- it is invoked by the sequence that originally sent the request item.
4.blocking nature:- it typically blocks the sequence's execution until the response becomes available
5.optional transaction id:- if specified,it identifies the specific transaction for which the response is sought.
*/

//a simple design module

module tenAdder(input [31:0]in,output int out);
  always@(in)
    begin
      out=in+10;
    end
endmodule

//testbench

`include "uvm_macros.svh"
import uvm_pkg::*;
class trans extends uvm_sequence_item;
  `uvm_object_utils(trans)
  function new(string n="trans");
    super.new(n);
  endfunction
  rand int a;
  int out;
endclass

class seq extends uvm_sequence#(trans);
  `uvm_object_utils(seq)
  function new(string n="seq");
    super.new(n);
  endfunction
  trans tr;
  task body;
    repeat(10)
      begin
        tr=trans::type_id::create("tr");
        wait_for_grant();
        tr.randomize() with {tr.a>0 && tr.a<200;};
        `uvm_info("seq",$sformatf("a=%0d",tr.a),UVM_NONE);
        send_request(tr);
        wait_for_item_done();
        get_response(tr);
        `uvm_info("seq",$sformatf("response from DUT : out=%0d",tr.out),UVM_NONE);
      end
  endtask
endclass

interface intf;
  int a,out;
endinterface

class driver extends uvm_driver #(trans);
	`uvm_component_utils(driver)
	function new(string n="Driver",uvm_component p=null);
		super.new(n,p);
	endfunction
	trans tr;
  virtual intf vif;
	function void build_phase(uvm_phase phase);
		super.build_phase(phase);
		tr=trans::type_id::create("tr");
      if(!uvm_config_db #(virtual intf)::get(this,"","key",vif))
        $error("unable to get vurtual interface");
	endfunction
  task inputs;
    seq_item_port.get_next_item(tr);
    vif.a=tr.a;
    #1;
    tr.out=vif.out;
    seq_item_port.item_done(tr);
  endtask
  task run_phase(uvm_phase phase);
    forever
      begin
        inputs;
      end
  endtask
endclass

class agent extends uvm_agent;
	`uvm_component_utils(agent)
	function new(string n="agent",uvm_component p=null);
		super.new(n,p);
	endfunction
	uvm_sequencer #(trans) sqr;
	driver drv;
    seq sq;
	function void build_phase(uvm_phase phase);
		super.build_phase(phase);
		sqr=uvm_sequencer #(trans)::type_id::create("sqr",this);
	 	drv=driver::type_id::create("drv",this);
        sq=seq::type_id::create("sq");
	endfunction
	function void connect_phase(uvm_phase phase);
		super.connect_phase(phase);
		drv.seq_item_port.connect(sqr.seq_item_export);
	endfunction
  task run_phase(uvm_phase phase);
    phase.raise_objection(this);
    sq.start(sqr);
    phase.drop_objection(this);
  endtask
endclass

module test;
  intf vif();
  tenAdder dut(vif.a,vif.out);
  initial 
    begin
      uvm_config_db#(virtual intf)::set(null,"*","key",vif);
      run_test("agent");
    end
endmodule
